

Qué es un módulo? 

Nivel de división superior al de paquete 

Agrupa un conjunto de paquetes e incluye información de 
dependencia de los mismos

public 
module // Da un nivel visibilidad superior al de paquetes.
protected
default
private

---------------------------


* Para poder usar una clase/proyecto por otra necesitamos su jar.

También hay otra forma que permite Eclipse, sin necesidad de generar el .jar

module modulo_operaciones {
	exports operaciones;
}

*module modulo_operaciones {
} // Puede estar vacío, solo que no exportas nada.


module modulo_uso_calculadora {
	requires modulo_operaciones;
}

// Cómo añadir librerias/proyectos externos que no stán en un .jar
// >properties>Build Path>Projects>Module Path>Nuestro modulo.
Calculadora cal = new Calculadora();

System.out.println("La suma es: " + cal.sumar(n1, n2));


>>>>>>>>>>>  Se exportan paquetes, se requieren módulos.
---------------------------


Módulos anónimos y automáticos (Mezclar apps modulares y no modulares). (Pregunta exámen)

Módulos anónimos son aquellos que no son modulares.

Las clases que no sean modulares, tienen acceso a las modulares. Porque no entiende de 
restricciones modulares.
Se deben añadir esos módulos al ClassPath.



Para que desde un módulo podamos usar un módulo anónimo, la solución es hacerlo automático.
Es decir, añadirlo al ModulePath, que lo convierte en automático y accesible.




>>>>>>>>
>>>>>>>>
>>>>>>>> Servicios: (Pregunta examen) 
>>>>>>>>
>>>>>>>>






Para exportar Interfaz de Servicio, hay que exportarla explícitamente.




Modulo servicio: (service.jar)

module servicio{
	exports com.interfaces.Interfaz1; //la interfaz con los métodos del servicio
	//otros paquetes a exportar
	//otros módulos a requerir
}

Modulo proveedor (el que crea la implementación de la interfaz):(provider.jar)

module provider{
	requires servicio;
	provides com.interfaces.Interfaz1 with provs.implementations.ClaseServiceImpl;
}
Module-path: service.jar


Modulo consumidor (el que utiliza las implementaciones para llamar a métodos): (consumer.jar)

module consumer{
	requires servicio; //solo es necesario requerir el módulo del servicio
	uses com.interfaces.Interfaz1;
}

Module-path: service.jar;provider.jar 




------------------------------------  30/05

Acceso por reflexión:

Es posible especificar que los paquetes especificados del 
módulo son accesibles vía reflexión a otros módulos : 
 
module moduloX{
	// Es necesario el exports, porque el opens solo no sirve. 
	 opens com.paquete;
}
 
Incluso, que lo sean solo a ciertos módulos:  
 
module moduloX{ 
	 opens com.paquete to modA, modB
}


-------------------------------------

Migración de aplicaciones (Pregunta exámen)

Cuando una app no modularizada y queremos convertirla en modular:

Se pueden seguir dos estrategias para realizar esta operación:

>>>>>>>>> Estrategia Buttom-Up (ascendente). Adecuada cuando se tiene la 
posibilidad de convertir cualquier .jar no modular en modular

	Aproximación Buttom-Up
	
	Se comienza migrando el .jar que no tiene ninguna dependencia a módulo 
	estándar (named). 
	
	Se continúa con el siguiente que menos dependencias tiene, y así hasta el 
	más alto en la jerarquía (más dependencias tiene)
	
	*Es decir, se empieza migrando por la que tiene menos dependencias hacia la que más.








>>>>>>>>> Estrategia Top-Down (descendente). Adecuada cuando no tenemos 
control sobre todos los .jar usados por la aplicación

Aunque lo más normal es:
	Aproximación Top-Down
	
	Se llevan todas las librerías al module path como módulos automáticos
	
	Se van migrando a módulo estándar uno a uno, comenzando por el que 
	más dependencias tiene


Ej: Del workspace de java_estandar, proyecto 18, usamos mysql y queremos migrarla a modular.


1º) Pasar las librerias de ClassPath a ModulePath  > ApplyAndClose

2º) Ya podemos hacer el top-down, para crear el module-info:
Proyecto>configure>Module-info> elegir nombre, normalmente se ponen por puntos: ej modulo.agenda
















