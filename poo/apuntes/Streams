
Streams: objeto para manipulación de datos.

Nunca se usa con bases de datos, sino con datos procedentes de arrays, collección o fichero, etc.

	Objeto que proporciona métodos para realizar de forma 
	rápida y sencilla operaciones de búsqueda, filtrado, 
	recolección, etc. sobre un grupo de datos (array, colección o 
	serie discreta de datos)
	
>>>>Para trabajar con streams utilizamos la interfaz Stream de 
	java.util.stream
	Es un objeto de esa interfaz.
	
	Otras variantes como IntStream, LongStream o 
	DoubleStream se emplean para trabajar con tipos primitivos
	
	// No es una colección.
	Recorre los datos desde el principio hasta el final y durante 
	el recorrido realiza algún tipo de cálculo u operación
	
	Una vez realizado el recorrido, el stream se cierra y no
	puede volver a utilizarse
	
>>>>>>>>>>>>>>>Se crea:

	A partir de una colección:
	ArrayList<Integer> nums=new ArrayList<>();
	nums.add(20);nums.add(100);nums.add(8);
	Stream<Integer> st=nums.stream();
	
	A partir de un array:
	String[] cads={“a”,”xy”,”jk”,”mv”};
	Stream<String>st= Arrays.stream(cads);
	
	A partir de una serie discreta de datos:
	Stream<Double> st=Stream.of(2.4, 7.4, 9.1);
	
	A partir de un rango de datos:
	IntStream stint=IntStream.range(1,10);
	IntStream stint2=IntStream.rangeClosed(1,10);
	
	
Además del método generate.

>>>>>>>
>>>>>>>
>>>>>>> MÉTODOS:
>>>>>>>
>>>>>>>
	
	Métodos intermedios. El resultado de su ejecución es 
	un nuevo Stream, para seguir aplicando más métodos. 
	Ejemplos: filtrado y transformación 
	de datos, ordenación, etc.
	
	Métodos finales. Generan un resultado. Pueden ser 
	void o devolver un valor resultado de alguna 
	operación. Ejemplos: calculo (suma, mayor, menor, …), 
	búsquedas, reducción, etc.

El proceso de aplicar sobre un objeto stream, un método intermedio, después otro método intermedio, 
y finalmente un método final.

Con un objeto stream, sólo puede hacerse una llamada.


Comprobaciones: métodos finales.

	boolean anyMatch(Predicate<? super T> predicate). 
	Devuelve true si algún elemento del Stream cumple con la 
	condición del predicado: 
	boolean allMatch(Predicate<? super T> predicate). 
	Devuelve true si todos cumplen con la condición del 
	predicado.
	boolean noneMatch(Predicate<? super T> predicate). 
	Devuelve true si ninguno cumple con la condición del 
	predicado.

Filtrado: otro intermedio, muy utilizado:

	Stream<T> filter(Predicate<? super T> predicate). 
	Aplica un filtro sobre el Stream, devolviendo un nuevo 
	Stream con los elementos que cumplen el predicado


Reducción a colección

>>>>>>>>>>>>>>>>>>>>>>collect // de lo más utilizado.
>>>>>>>>>>>>>>>>>>>>>>

El resultado puede ser cualquier tipo.
Finalidad, reducir.



Recibe como parámetro un Collector, que no es funcional.
Para proporcionar una implementación de Collector: 
* clase Collectors, que tiene muchos métodos estáticos, definidos para
devolver determinado tipo.
Collectors.<tipo>, y devuelven una implementación de Collector

Ej: 

	// Método que a partir de un nombre de divisa nos dice las cuentas que hay de dicha divisa
	public List<Cuenta> cuentasDivisas(String divisa) {
		 return cuentas.stream()
				.filter(d -> d.getDivisa().equalsIgnoreCase(divisa))
				//.collect(Collectors.toList());
				.toList();
	}
	// A partir de java 16, está disponible ese método toList()
	
	
	Ej:
	// Método que devuelva un Map con los números de cuenta como claves 
	// y saldo como valor
	
	public Map<String, Double> cuentasSaldo(){
		
		return cuentas.stream()
				.collect(Collectors.toMap(c -> c.getNumeroCuenta(), s -> s.getSaldo()));
				//.collect(Collectors.toMap(Cuenta::getNumeroCuenta, Cuenta::getSaldo));
	}



Otros usos de collect:

Hacer agrupaciones.

Hay un tipo de agrupación diferente: Partición, resultado boolean.

	// Método que devuelve en una tabla de cuentas agrupadas por divisas:
	public Map<String, List<Cuenta>> cuentasPorDivisa(){
		return cuentas.stream()
				.collect(Collectors.groupingBy(c -> c.getDivisa()));
				// Así devuelve directamente la agrupación.
	}
	

	// Ahora la suma de cada grupo, por una lado los negativos, por otro los positivos:
	Map<Boolean, Integer> tabla2 = nums.stream()
	.collect(Collectors.partitioningBy(n -> n>0, Collectors.summingInt(n -> n)));
	
	System.out.println(tabla2.values());

	
	
	// Aqui collector acumula todo con summigInt.
	
	
	
	
>>>>>>>>>>>>>>>>>>>> flatMap

>>>>>>>>>>>>>>>>>>>> peek, método intermedio.

Diferencia del foreach es que devuelve el stream para seguir utilizándolo.

	Stream<T> peek(Consumer<? super T> proceso). Aplica
	el consumer a cada elemento del Stream, devolviendo un 
	nuevo stream idéntico para continuar con la 
	manipulación de los elementos: 
	
	
	
>>>>>>>>>>>>>>>>>>>> otro uso de métodos intermedios:
>>>>>>>>>>>>>>>>>>>> funcionan en modo lazy, es decir, lo que hacen se realiza en memoria.