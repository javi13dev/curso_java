poo

Herencia
********************************************
********************************************
********************************************


Todas las clases Java heredan Object.
Si una clase no hereda ninguna otra de forma explícita, implícitamente heredará Object 

ventajas de la herencia: Reutilización de código.

Si tiene un extends, ahora hereda de esa clase.

Al ejecutar el constructor de la clase hija, se ejecuta el constructor de la clase padre.
Es implícita la llamada al constructor sin parámetro ->   super();

	public Punto(int x, int y) {
		this.x=x;
		this.y=y;
	}
	public Punto() {
		x=5;
		y=10;
	}
	
	
	---------->

	public static void main(String[] args) {
		Punto3D pd = new Punto3D(25);
		
		// ahora pd. tiene todos los métodos, tanto de object como de la clase padre Punto.
		pd.imprimir();

	}
	
En el momento de crear pd, se ejecuta el constructor de Punto. Por tanto, el constructor de la clase padre debe estar definida,sino da un error
de compilación.

Si la clase padre NO tiene constructores, java crea un constructor vacío por defecto. En este caso si se crea pd no daría problemas.


super:  para llamar también a métodos de la superclase, cuando por ejemplo hay duplicidad de métodos.
		Si no hay lugar a confusión, podriamos usarlo sin el super.
		
this y super, no sirven para llamar nada estático, a lo estático se le llama con el nombre de la clase . 
Ej:  Clase.metodo()
		
----> Algunas clases no se pueden heredar. 
Las clases final no se pueden heredar.
Ej, los String, las clases envotorio, LocalDate.
(Clases que tienen funcionalidad muy definida)

final: en métodos, supone que no se pueden sobreescribir.





 

Sobrecarga 
********************************************
********************************************
********************************************

De métodos o de constructores.


public void print(int a){
	System.out.println("uno");
}
public void print(String a){
	System.out.println("dos");
}
public void print(int a,int b){
	System.out.println("tres");
}
public void print(long r){
	System.out.println("cuatro");
}

print(25);  //imprime uno 











Sobreescritura
********************************************
********************************************
********************************************


Volver a escribir el método, respetando la estructura
	
	// método imprimir de la clase padre
	
	public void imprimir() {
		System.out.print("Las coordenadas son: "+x+","+y);
	}

	// para sobreescribir métodos, en source>override/implementsmethods
	
	@Override
	public void imprimir() {
		// Llamada a super porque primero llama al método del padre si es necesario y después lo modificamos/añadimos
		super.imprimir();
		System.out.println(","+z);
	}


Reglas:

- respetar el nombre y la lista de parámetros
- el ámbito public/privado no tiene por qué ser el mismo, pero el posterior debe ser menos restrictivo.	
  Siempre puede ampliarse la visibilidad.
- tipo de devolución, no tiene por qué ser el mismo. Puede ser el mismo o un subtipo del original.

Ej: correcto.

	class C1{
		Number calcular(){
		}
	}
	
	class C2 extends C1{
		Integer calcular(){
		}
	}
	
- sobre excepciones, el método posterior no debe propagar excepciones que no estén definidas en el original.
  Esto no afecta a las excepciones del Runtime.
  
  	class C1{
		public void m(){
		}
	}
	
	class C2 extends C1{
		@override
		public void m() throws IOException{ // Error, al no haber estado declarada en la original.
		}
	}
	
	--------------------
	
  	class C1{
		public void m() throws IOException{
		}
	}
	
	class C2 extends C1{
		@override
		public void m() throws FileNotFoundException{ // correcto, ya que es hija de la exception padre.
		}
	}
  
  
  
  
  
  
  
  

Clases abstractas
********************************************
********************************************
********************************************
El objetivo es definir la plantilla para que las clases hijas las desarrollen.


Las clases hijas deben sobreescribir los métodos abstractos heredados, salvo que se declaren como abstractas.

Si queremos un método abstracto, la clase también debe ser asbtracta.

No podemos instanciar objetos de clase abstracta.


	package service;
	
	public abstract class Figura {
		private String color;
		
		public Figura(String color) {
			this.color = color;
		}
		
		public abstract double area();
	}




Interfaces
********************************************
********************************************
********************************************

Descripción de métodos abstractos públicos.
Sin atributos ni constructores.

Posteriormente las clases se encargarán de implementarlas.

Puede tener constantes.

Una clase que implementa una interfaz está obligada a sobreescribir(implementar) todos los métodos de la misma.
Debe respetarse el modificador.

Así las clases que implementen, respetan el formato establecido.


Aporta flexibilidad, una clase a diferencia de las abstractas, puede implementar distintas interfaces.
Además, una subclase, puede implementar interfaces.

Una interfaz puede heredar de otra o varias.
Así va sumando métodos.

Ej: interfaz Collection es padre de las demás collecciones

Con las interfaces también se puede usar polimorfismo.
Ej:

Interface I1{

}
class C1 implements I1{

}
class C2 extends C1{

}

I1 i = new C2(); // Sí, porque C2 al ser extends C1, hereda la interfaz I1
C2 x = newC1(); // No
I1 r = new C1(); C2 a = (C1) r ;  // No, una hija no se puede igualar al padre
C1 v = (C1) new I1(); // No, no se puede instanciar una intefaz


>>>>>>>>>>>Uso mayoritario:
métodos que nos encontramos en clases, al que se le pasa un parámetro que es una interfaz.
El uso es más flexible y amplio que las clases abstractas.


EJ:
	usoPolimorfismo(new Test(..));
	usoPolimorfismo(new Circulo(..));
	:
	void usoPolimorfismo(Operaciones op){
		 op.girar(200);
		 op.invertir();
	}


// Hay posibilidad donde se indica que se devuelve una interfaz, lo que quiere decir es que será un objeto de ese tipo.
// Como en este ejemplo que indica que se devolverá un List<E>
Ej: static <E> List<E>         checkedList(List<E> list, Class<E> type)

USO:
Se gana asi eficiencia en el código. Desacoplamiento entre capas.(Uno de los principios de clean code).
Si devolvemos interfaces no debería requerir de muchos cambios si se usa una clase diferente que lo implemente.

Ej: en el proyecto 47 d gestor pedidos, habría que cambiar el ArrayList por un List.





>>>>>>>>>>> Interfaz que tiene sólo un método abstracto, es una interfaz funcional.
Opcionalmente puede tener la anotación:
@FunctionalInterface


Ejemplo de interfaz funcional:
@FunctionalInterface
interface InterC{
	 void m();
	 String toString(); //los métodos abstractos que 
						//coincidan con algún método de
						//Object no se tiene en cuenta de 
						//cara a la característica de ser funcional
}


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LAMBDAS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 


Son la solución a que no sea necesario cada implementación de las interfaces.

Es la implementación de una interfaz funcional, sin necesidad de crear una clase.

Ej:

// Interfaz funcional
public interface Inter1{
	 void met(int data);
	 default int res(){return 1;}
}


// Expresión lambda
Inter1 i1=(a)->System.out.println(a);
// Con esto, se implementa/genera un objeto de la interfaz.


Se usan como parámetros en una función.




>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Programación funcional


Podemos crear nuestras funciones y usar expresiones lambdas para su posterior implementación:

Ej:


	package service;
	
	import java.util.List;
	import java.util.Map;
	import java.util.Set;
	import java.util.function.BiConsumer;
	import java.util.function.BiFunction;
	import java.util.function.BiPredicate;
	import java.util.function.BinaryOperator;
	import java.util.function.Consumer;
	import java.util.function.Function;
	import java.util.function.IntSupplier;
	import java.util.function.Supplier;
	
	public class FuncionalesService {
		
		// Práctica común, encontrarse con clases y métodos de llamadas funcionales/lambdas
		
		public void m1(Set<Integer> nums, Function<String, Integer> fn) {
		
		}
		
		public void m2(Supplier<String> sp, Consumer<Integer> cs) {
			
		}
		
		public void m3(BinaryOperator<Double> db, BiFunction<Integer, String, Integer> bf ) {
			
		}
		
		public void m4(BiConsumer <String, Double> bc, BiPredicate<String, Long> bp) {
			
		}
		
		public void m5(IntSupplier is, List<String> lst) {
			
		}
		
		public void m6(Map <String, Integer> mp, BiConsumer<String, Long> bc) {
			
		}
		
		public void m7(Function<String, List<Integer>> fn) {
			
		}
		
	}


O bien, utilizar las nuevas funciones que reciben como parámetros expresiones lambdas:

		package service;
		import java.util.ArrayList;
		import java.util.List;
		
		import model.Producto;
		
		public class ProductoService {
			List<Producto> lst = new ArrayList<Producto>();
		
			/**
			 *  Programa para gestión de productos.
		
				Cada producto tendrá: nombre, precio, categoria
				
				La lógica de negocio, expondrá los siguientes métodos:
				
				-eliminarPorCategoria: elimina de la lista aquellos productos que pertenezcan a la categoría indicada
				
				-bajarPrecio: Baja el precio de todos productos en el porcentaje indicado
				
				-subirPrecioCategoria: Sube el precio a todos los productos de la categoría indicada, en el porcentaje indicado
				
				-obtenerProductos: Devuelve la lista de productos existentes
				-agregarProducto: Añade el producto recibido 
			 */
			
			public void eliminarPorCategoria( String categoria) {
				
				lst.removeIf(p -> p.getCategoria().equals(categoria));	
			}
			
			public void bajarPrecio(int porcentaje) {
				lst.forEach(p -> p.setPrecio(p.getPrecio() - p.getPrecio()*porcentaje/100));
			}
			
			public void subirPrecioCategoria(int porcentaje, String categoria) {
				
				lst.replaceAll(p -> {
					if(p.getCategoria().equals(categoria)) {
						 p.setPrecio(p.getPrecio() + p.getPrecio()*porcentaje/100);
					}
					return p;
				});
				
				lst.forEach(p -> p.setPrecio(p.getPrecio() + p.getPrecio()*porcentaje/100));	
			}
			
			
			public List<Producto> obtenerProductos(){
				return lst;
			}
			
			public void altaProdcuto(Producto producto){
				lst.add(producto);
			}
			 
		}

// En este caso lst utiliza directamente las funciones nuevas.


				// Lambdas
				// No se pueden usar variables locales, a menos que sean constantes efectivas.
>>>>>>>>>>>>>>>>>Permite el uso de constantes o constantes efectivas, es decir,


		package pruebas;
		
		import java.util.function.Consumer;
		
		public class PruebaLambda {
		
			// Variables de clase sí son posibles usarlas:
			// Ej:
			public static int s = 1;
			
			public static void main(String[] args) {
				// Lambdas
				// No se pueden usar variables locales, a menos que sean constantes efectivas.
				// Permite el uso de constantes o constantes efectivas, es decir,
				// variables que no cambien de valor.
				
				// Ej:
				int a = 2;
				
				// a++; 
				// Si la variable a se modifica generará un error en el desarrollo de la expresión lambda.
				Consumer<Integer> cons = x -> System.out.println(x+a);
			}
		
		}







Polimorfismo
********************************************
********************************************
********************************************

Muy habitual, guardar variables de una clase, en una variable de la superclase.

Ej:

String s = "hello";
Object ob = s;

Integer n=200;
Number f=n;




Accesibilidad/ Visibilidad
********************************************
********************************************
********************************************

Public(desde cualquier ámbito)

Default(ámbito de paquete en el que está definido)

Private(uso interno de la propia clase)
No está permitido en clases.
Ej de clase con constructor privado: LocalDate


Protected:

Es más que default y menos que public.


El modificador de acceso protected puede utilizarse en la declaración de atributos y métodos. 
Si uno de estos elementos se declara como protected, significa que es accesible desde 
cualquier clase de su mismo paquete y de sus subclases, independientemente de donde estas 
se encuentren.
Por tanto, el modificador protected establece una visibilidad a los miembros de una clase que 
es superior a la default (ámbito de paquete), pero inferior a la public.
El acceso desde una subclase a un miembro protected de la superclase se debe hacer siempre 
dentro del contexto de la herencia. Veamos un ejemplo, tenemos la siguiente clase:

	package p1;
	public class Prueba{
		protected int k=2;
		protected void metodo(){}
	}
	
Si definimos una subclase de Prueba en otro paquete, desde el interior de esta clase se tendrá 
acceso a k y metodo():


	package p2;
	public class Test extends Prueba{
		public void nuevoMetodo(){
			this.k=10;// correcto
			this.metodo();
		}
	}

Sin embargo, si desde una subclase que se encuentre en otro paquete distinto a p1 creamos 
un objeto de la clase Prueba, no tendremos acceso a los miembros protegidos a través de 
este objeto. Esto es lo que significa que el acceso solo sea a través del contexto de la herencia:


	package p3;
	public class Nueva extends Prueba{
		public void miMetodo(){
			Prueba p=new Prueba();
			p.k=3; //error de compilación
			p.metodo(); //error de compilación
		}
	}

