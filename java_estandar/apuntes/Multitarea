Multitarea:

Ejecución de varios procesos simultáneamente. 

A diferencia de la ejecución secuencial, el gestor de 
multitarea de Java reparte el tiempo de CPU entre los 
procesos.

3 formas:

>>>>>>>>>> clásica

	1) mediante herencia, extendiendo la clase Thread
	
Proporciona el método run(), que debe ser sobrescrito para 
incluir el código de la tarea/tareas.

	public class Tarea extends Thread{
		 public void run(){
		 //código de la tarea
		 }
	}
	// Para cada tarea se crea un run()
	
Para poner en ejecución concurrente las tareas, se llamará al 
método start() de Thread, que invoca al gestor de multitarea de 
Java para que ponga los objetos en ejecución concurrente:


	Tarea t1=new Tarea();
	Tarea t2=new Tarea();
	t1.start();
	t2.start();
	// Así se ejecutan concurrentemente.
	
	Ej: 22_ejemplo_multitarea
	
	definimos un ejemplo:
	
	package tareas:
		
		public class TareaAscendente extends Thread {
			@Override
			public void run() {
			}
		}
		
		
		
		
	
	2) Implmentando interfaz Runnable (más usada)
	
	Ya que heredar Thread no permite heredar otra clase.
	
Incluye el método run() y permite a las clases que la 
implementan poder heredar otras clases:

	public class Tarea implements Runnable{
		 public void run(){
		 //código de la tarea
		 }
	}
	
	
Para poner las tareas en ejecución, se crearán instancias de 
Thread a partir del objeto Runnable:
	
	Tarea obj=new Tarea();
	Thread t1=new Thread(obj);
	Thread t2=new Thread(obj);
	t1.start();
	t2.start();



>>>>>>>>>>>> 10/05

java.util.concurrent: Hay clases como:

CopyOnWriteArrayList<E> (thread seguro), evita bloques sincronizados. Permite trabajar varios hilos sobre el mismo conjunto.

En caso de tablas: ConcurrentMap, equivalente al HashMap pero ThreadSeguro.


>>>>>>>>>>>> 13/05

Paquete: package java.util.concurrent.atomic

https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html

Las clases Atomic, con thread seguro.

Por ejemplo para tener un contador como del 26_recursos_compartidos, mejor usar un AtomicInteger.
Ej: si hay mil hilos llamando al incrementAndGet(), se realizará correctamente en cada uno. (usan variables volátiles)

34_recursos-compartidos_atomic


>>>>>> stremas paralelos

35_streams_paralelos





















-moderna

-desde java 21: virtual